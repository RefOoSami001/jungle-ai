<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Generated Quiz</title>
    <link rel="stylesheet" href="/static/styles.css">
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <script src="/static/common.js"></script>
  </head>
  <body>
    <div class="container">
      <div class="topbar">
        <div class="brand">
          <div class="logo">QG</div>
          <p>RefOo Quiz Generator</p>
        </div>
        <a href="/" class="btn ghost" style="margin-left:auto;flex-shrink:0;padding:8px 16px;font-size:14px;text-decoration:none;display:inline-flex;align-items:center;gap:6px">
          <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M19 12H5M12 19l-7-7 7-7"/>
          </svg>
          <span>Return</span>
        </a>
      </div>
      <div id="deck-id" style="display:none">{{ deck_id }}</div>

      <div class="card" style="margin-bottom:12px;padding:12px;background:rgba(111,76,255,0.05);border:1px solid rgba(111,76,255,0.1)">
        <div style="font-size:12px;color:var(--muted);margin-bottom:8px">Quiz ID (Share this to let others access this quiz):</div>
        <div style="display:flex;align-items:center;gap:8px;flex-wrap:wrap">
          <div id="quiz-id-display" style="font-family:monospace;font-size:16px;font-weight:600;color:var(--accent);word-break:break-all;flex:1;min-width:200px">{{ deck_id }}</div>
          <button id="copy-quiz-id-btn" class="btn ghost" style="flex-shrink:0;padding:8px 16px;font-size:14px">Copy ID</button>
        </div>
      </div>

      <div id="loading-indicator" class="loading-overlay">
        <div class="loading-content">
          <div class="spinner"></div>
          <div style="margin-top:16px;color:var(--muted);font-size:14px">Generating questions...</div>
        </div>
      </div>

      <div class="card">
        <div class="meta" id="progress">Question 0 of 0</div>
        <div id="cards" class="quiz-grid">
          <!-- Single-card exam UI will be rendered client-side. If any initial cards were passed, they will be shown by JS. -->
        </div>
      </div>

      <div class="fixed-controls">
        <div class="control-row" style="display:flex;gap:12px;align-items:center">
          <div class="left-controls" style="flex:1;display:flex;gap:8px;align-items:center">
            <button id="prev" class="btn ghost prev-button" style="width:100%">Previous</button>
          </div>
          <div class="right-controls" style="flex:4">
            <button id="next" class="btn next-button" style="width:100%">Next</button>
          </div>
        </div>
      </div>

      <!-- Floating button to send quiz to Telegram -->
      <button id="send-to-telegram-btn" class="floating-btn" title="Send quiz to Telegram">
        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <path d="M22 2L11 13"></path>
          <path d="M22 2l-7 20-4-9-9-4 20-7z"></path>
        </svg>
      </button>

    </div>

    <script>
      (function(){
        'use strict';
        
        const deckId = document.getElementById('deck-id').textContent.trim();
        const cardsContainer = document.getElementById('cards');
        
        // Exam state
        const cards = [];
        let currentIndex = 0;

        const prevBtn = document.getElementById('prev');
        const nextBtn = document.getElementById('next');
        const progress = document.getElementById('progress');
        const loadingIndicator = document.getElementById('loading-indicator');
        
        let eventSource = null;
        let hasShownFirstCard = false;

        function renderCardAt(index) {
          const slot = document.getElementById('card-slot');
          if (!slot) return;
          
          slot.innerHTML = '';
          
          if (cards.length === 0) {
            slot.innerHTML = '<div class="card-quiz"><div class="q">No cards yet — waiting for generation</div></div>';
            progress.textContent = 'Question 0 of 0';
            prevBtn.disabled = true;
            nextBtn.disabled = true;
            return;
          }
          
          const card = cards[index];
          if (!card) return;
          
          progress.textContent = `Question ${index + 1} of ${cards.length}`;

          const wrapper = document.createElement('div');
          wrapper.className = 'card-quiz';
          wrapper.setAttribute('data-card-id', card.card_id);
          
          if (card.card_type) {
            const badge = document.createElement('div');
            badge.className = 'badge';
            badge.textContent = card.card_type;
            wrapper.appendChild(badge);
          }
          
          if (card.case_details) {
            const caseDiv = document.createElement('div');
            caseDiv.className = 'case';
            caseDiv.innerHTML = `<em>Case:</em> ${card.case_details}`;
            wrapper.appendChild(caseDiv);
          }
          
          const questionDiv = document.createElement('div');
          questionDiv.className = 'q';
          questionDiv.textContent = card.question;
          wrapper.appendChild(questionDiv);

          if (card.options && card.options.length) {
            const optionsContainer = document.createElement('div');
            optionsContainer.className = 'options';
            
            card.options.forEach((option, optionIndex) => {
              const label = document.createElement('label');
              label.className = 'option';
              
              const input = document.createElement('input');
              input.type = 'radio';
              input.name = 'answer';
              input.value = option;
              input.id = `opt${optionIndex}`;
              label.appendChild(input);

              const inner = document.createElement('div');
              inner.className = 'option-inner';
              
              const textDiv = document.createElement('div');
              textDiv.className = 'option-text';
              textDiv.textContent = option;
              inner.appendChild(textDiv);
              
              // Add icon containers for checkmark/X
              const checkIcon = document.createElement('div');
              checkIcon.className = 'option-icon check-icon';
              checkIcon.innerHTML = '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"><polyline points="20 6 9 17 4 12"></polyline></svg>';
              
              const xIcon = document.createElement('div');
              xIcon.className = 'option-icon x-icon';
              xIcon.innerHTML = '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>';
              
              inner.appendChild(checkIcon);
              inner.appendChild(xIcon);
              label.appendChild(inner);

              // Add click animation
              label.addEventListener('click', function() {
                if (label.dataset.locked) return;
                inner.classList.add('animating');
                setTimeout(() => {
                  inner.classList.remove('animating');
                }, 400);
              });

              // Immediate validation when user selects an option
              input.addEventListener('change', function() {
                if (label.dataset.locked) return;
                label.dataset.locked = '1';

                const answerDiv = wrapper.querySelector('.answer');
                const cardTypeLower = String(card.card_type || '').toLowerCase();
                
                // Understanding/explanation type — show blurred content, allow reveal
                if (cardTypeLower.includes('understand') && answerDiv) {
                  answerDiv.style.display = 'block';
                  answerDiv.classList.add('blurred');
                  
                  const revealHandler = function() {
                    answerDiv.classList.remove('blurred');
                    answerDiv.classList.add('revealed');
                    answerDiv.removeEventListener('click', revealHandler);
                  };
                  answerDiv.addEventListener('click', revealHandler);
                  
                  // Lock inputs
                  wrapper.querySelectorAll('input[name=answer]').forEach(inp => inp.disabled = true);
                  return;
                }

                // MCQ / standard validation
                const selectedValue = input.value;
                const isCorrect = selectedValue === (card.answer || '');

                // Clear any previous highlights and icons
                wrapper.querySelectorAll('.option-inner').forEach(optionInner => {
                  optionInner.classList.remove('correct', 'incorrect');
                  optionInner.querySelectorAll('.option-icon').forEach(icon => {
                    icon.style.opacity = '0';
                    icon.style.transform = 'translateY(-50%) scale(0)';
                    icon.style.display = 'flex';
                  });
                });

                // Add slight delay for better animation effect
                setTimeout(() => {
                  const chosenInner = input.closest('.option').querySelector('.option-inner');
                  if (chosenInner) {
                    if (isCorrect) {
                      chosenInner.classList.add('correct');
                      const check = chosenInner.querySelector('.check-icon');
                      const x = chosenInner.querySelector('.x-icon');
                      if (check) {
                        check.style.opacity = '1';
                        check.style.transform = 'translateY(-50%) scale(1)';
                        check.style.display = 'flex';
                      }
                      if (x) {
                        x.style.display = 'none';
                      }
                    } else {
                      chosenInner.classList.add('incorrect');
                      const check = chosenInner.querySelector('.check-icon');
                      const x = chosenInner.querySelector('.x-icon');
                      if (x) {
                        x.style.opacity = '1';
                        x.style.transform = 'translateY(-50%) scale(1)';
                        x.style.display = 'flex';
                      }
                      if (check) {
                        check.style.display = 'none';
                      }
                      
                      // Highlight correct one with delay
                      setTimeout(() => {
                        const correctInput = Array.from(wrapper.querySelectorAll('input[name=answer]'))
                          .find(inp => inp.value === (card.answer || ''));
                        if (correctInput) {
                          const correctInner = correctInput.closest('.option').querySelector('.option-inner');
                          if (correctInner) {
                            correctInner.classList.add('correct');
                            const check = correctInner.querySelector('.check-icon');
                            const x = correctInner.querySelector('.x-icon');
                            if (check) {
                              check.style.opacity = '1';
                              check.style.transform = 'translateY(-50%) scale(1)';
                              check.style.display = 'flex';
                            }
                            if (x) {
                              x.style.display = 'none';
                            }
                          }
                        }
                      }, 200);
                    }
                  }

                  // Show answer text if an answer block exists
                  if (answerDiv) {
                    answerDiv.style.display = 'block';
                    answerDiv.textContent = `${isCorrect ? 'Correct — ' : 'Incorrect — '}Answer: ${card.answer || ''}`;
                  }

                  // Lock inputs
                  wrapper.querySelectorAll('input[name=answer]').forEach(inp => inp.disabled = true);
                }, 50);
              });

              optionsContainer.appendChild(label);
            });
            wrapper.appendChild(optionsContainer);
          }

          // For understanding/explanation cards render a blurred explanation block that can be revealed
          const cardTypeLower = String(card.card_type || '').toLowerCase();
          if (cardTypeLower.includes('understand')) {
            const answerDiv = document.createElement('div');
            answerDiv.className = 'answer';
            answerDiv.textContent = card.explanation || card.answer || '';
            answerDiv.style.display = 'block';
            answerDiv.classList.add('blurred');
            
            const revealHandler = function() {
              answerDiv.classList.remove('blurred');
              answerDiv.classList.add('revealed');
              answerDiv.removeEventListener('click', revealHandler);
            };
            answerDiv.addEventListener('click', revealHandler);
            wrapper.appendChild(answerDiv);
          }
          
          cardsContainer.innerHTML = '';
          const slotWrap = document.createElement('div');
          slotWrap.id = 'card-slot';
          slotWrap.appendChild(wrapper);
          cardsContainer.appendChild(slotWrap);

          // Update navigation buttons
          prevBtn.disabled = (index === 0);
          nextBtn.disabled = (index >= cards.length - 1);
        }

        prevBtn.addEventListener('click', function() {
          if (currentIndex > 0) {
            currentIndex--;
            renderCardAt(currentIndex);
          }
        });
        
        nextBtn.addEventListener('click', function() {
          if (currentIndex < cards.length - 1) {
            currentIndex++;
            renderCardAt(currentIndex);
          }
        });

        // Selection is handled immediately on input change (see input listeners created when rendering options).

        // Initial empty slot
        const slotInit = document.createElement('div');
        slotInit.id = 'card-slot';
        cardsContainer.appendChild(slotInit);

        function hideLoadingIndicator() {
          if (loadingIndicator && !hasShownFirstCard) {
            loadingIndicator.style.display = 'none';
            hasShownFirstCard = true;
          }
        }

        // Connect EventSource
        function connectEventSource() {
          eventSource = new EventSource(`/stream_cards/${encodeURIComponent(deckId)}`);
          
          eventSource.onmessage = function(event) {
            try {
              const payload = JSON.parse(event.data);
              if (!payload || !payload.cards) return;
              
              let hasNewCards = false;
              payload.cards.forEach(card => {
                if (!card.card_id) return;
                if (!cards.find(c => c.card_id === card.card_id)) {
                  cards.push(card);
                  hasNewCards = true;
                }
              });
              
              // Render current card when ready
              if (hasNewCards) {
                renderCardAt(currentIndex);
                // Hide loading indicator when first card appears
                if (cards.length > 0) {
                  hideLoadingIndicator();
                }
              }
            } catch (err) {
              console.error('Invalid message:', err, event.data);
            }
          };

          eventSource.addEventListener('done', function() {
            if (eventSource) {
              eventSource.close();
              eventSource = null;
            }
          });

          eventSource.onerror = function(err) {
            console.error('EventSource failed:', err);
            // Attempt to reconnect after a delay
            if (eventSource) {
              eventSource.close();
              eventSource = null;
              setTimeout(connectEventSource, 5000);
            }
          };
        }
        
        connectEventSource();
        
        // Cleanup on page unload
        window.addEventListener('beforeunload', function() {
          if (eventSource) {
            eventSource.close();
            eventSource = null;
          }
        });

        // Copy Quiz ID functionality
        const copyQuizIdBtn = document.getElementById('copy-quiz-id-btn');
        const quizIdDisplay = document.getElementById('quiz-id-display');
        
        copyQuizIdBtn.addEventListener('click', function() {
          const quizId = quizIdDisplay.textContent.trim();
          
          if (navigator.clipboard && navigator.clipboard.writeText) {
            navigator.clipboard.writeText(quizId).then(function() {
              const originalText = copyQuizIdBtn.textContent;
              copyQuizIdBtn.textContent = 'Copied!';
              copyQuizIdBtn.style.background = 'var(--accent)';
              copyQuizIdBtn.style.color = 'white';
              
              setTimeout(function() {
                copyQuizIdBtn.textContent = originalText;
                copyQuizIdBtn.style.background = '';
                copyQuizIdBtn.style.color = '';
              }, 2000);
            }).catch(function(err) {
              console.error('Failed to copy:', err);
              alert(`Failed to copy. Quiz ID: ${quizId}`);
            });
          } else {
            // Fallback for older browsers
            const textArea = document.createElement('textarea');
            textArea.value = quizId;
            textArea.style.position = 'fixed';
            textArea.style.opacity = '0';
            textArea.style.left = '-9999px';
            document.body.appendChild(textArea);
            textArea.select();
            
            try {
              const success = document.execCommand('copy');
              if (success) {
                const originalText = copyQuizIdBtn.textContent;
                copyQuizIdBtn.textContent = 'Copied!';
                setTimeout(function() {
                  copyQuizIdBtn.textContent = originalText;
                }, 2000);
              } else {
                alert(`Failed to copy. Quiz ID: ${quizId}`);
              }
            } catch (err) {
              alert(`Failed to copy. Quiz ID: ${quizId}`);
            }
            
            document.body.removeChild(textArea);
          }
        });
        
        // Initialize Telegram WebApp
        initTelegramWebApp();
        
        // Notify admin when mini app is opened
        notifyAdmin('quiz');
        
        // Send to Telegram functionality
        const sendToTelegramBtn = document.getElementById('send-to-telegram-btn');
        let isSending = false;
        
        sendToTelegramBtn.addEventListener('click', async function() {
          if (isSending || cards.length === 0) {
            return;
          }
          
          // Get user ID from Telegram WebApp
          const userInfo = getTelegramUserInfo();
          if (!userInfo.id) {
            alert('Unable to get your Telegram user ID. Please make sure you opened this from Telegram.');
            return;
          }
          
          // Confirm before sending
          const confirmSend = confirm(`Send ${cards.length} question${cards.length > 1 ? 's' : ''} to your Telegram chat?`);
          if (!confirmSend) {
            return;
          }
          
          isSending = true;
          sendToTelegramBtn.disabled = true;
          sendToTelegramBtn.style.opacity = '0.6';
          
          try {
            const response = await fetch('/api/send-to-telegram', {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json'
              },
              body: JSON.stringify({
                cards: cards,
                user_id: userInfo.id
              })
            });
            
            const result = await response.json();
            
            if (result.success) {
              alert(`✅ Successfully sent ${result.sent} question${result.sent > 1 ? 's' : ''} to your Telegram chat!${result.skipped > 0 ? `\n\n⚠️ ${result.skipped} question${result.skipped > 1 ? 's were' : ' was'} skipped.` : ''}`);
            } else {
              alert(`❌ Failed to send questions: ${result.error || 'Unknown error'}`);
            }
          } catch (error) {
            console.error('Error sending to Telegram:', error);
            alert('❌ Error sending questions to Telegram. Please try again.');
          } finally {
            isSending = false;
            sendToTelegramBtn.disabled = false;
            sendToTelegramBtn.style.opacity = '1';
          }
        });
        
      })();
    </script>
  </body>
</html>
