<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Generated Quiz</title>
    <link rel="stylesheet" href="/static/styles.css">
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <script src="/static/common.js"></script>
  </head>
  <body>
    <div class="container">
      <div class="topbar" style="position:relative">
        <div class="brand">
          <div class="logo">QG</div>
          <p>RefOo Quiz Generator</p>
        </div>
        <a href="/" class="btn ghost" style="margin-left:auto;flex-shrink:0;padding:8px 16px;font-size:14px;text-decoration:none;display:inline-flex;align-items:center;gap:6px">
          <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M19 12H5M12 19l-7-7 7-7"/>
          </svg>
          <span>Return</span>
        </a>
        <!-- menu button placed next to return -->
        <div id="dots-menu" style="margin-left:8px;display:inline-block;align-self:center">
          <button id="menu-btn" class="btn ghost" title="Options" aria-haspopup="true" aria-expanded="false" style="margin-left:8px;flex-shrink:0;padding:8px 16px;font-size:14px;text-decoration:none;display:inline-flex;align-items:center;gap:6px;border-radius:8px">
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <circle cx="5" cy="12" r="1.5"></circle>
              <circle cx="12" cy="12" r="1.5"></circle>
              <circle cx="19" cy="12" r="1.5"></circle>
            </svg>
          </button>

          <div id="menu-popup" style="position:absolute;top:56px;right:0;min-width:240px;background:var(--card-bg);backdrop-filter:blur(6px);border-radius:10px;padding:12px;border:1px solid rgba(16,24,40,0.04);box-shadow:0 8px 24px rgba(15,23,42,0.06);display:none;z-index:1001">
            <div style="font-size:12px;color:var(--muted);margin-bottom:6px">Quiz ID</div>
            <div id="quiz-id-display" style="font-family:monospace;font-size:14px;font-weight:600;color:var(--accent);word-break:break-all;">{{ deck_id }}</div>
            <div style="display:flex;gap:8px;margin-top:10px;flex-direction:column">
              <div style="display:flex;gap:8px">
                <button id="copy-id-action" class="btn ghost" style="flex:1;padding:8px 10px">Copy ID</button>
                <button id="share-telegram-action" class="btn" style="flex:1;padding:8px 10px;display:flex;align-items:center;gap:8px;justify-content:center">
                  <!-- telegram icon -->
                  <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="flex-shrink:0">
                    <path d="M22 2L11 13"></path>
                    <path d="M22 2l-7 20-4-9-9-4 20-7z"></path>
                  </svg>
                  <span>Send to Telegram Chat</span>
                </button>
              </div>

              <div style="margin-top:10px;border-top:1px solid rgba(16,24,40,0.04);padding-top:10px;">
                <div style="font-size:12px;color:var(--muted);margin-bottom:8px">Export</div>
                <div class="export-grid" style="display:grid;grid-template-columns:repeat(2,1fr);gap:8px">
                  <button data-export="pdf" class="btn ghost">Export PDF</button>
                  <button data-export="docx" class="btn ghost">Export Word</button>
                  <button data-export="json" class="btn ghost">Export JSON</button>
                  <button data-export="csv" class="btn ghost">Export CSV</button>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
      <div id="deck-id" style="display:none">{{ deck_id }}</div>

      

      <div id="loading-indicator" class="loading-overlay">
        <div class="loading-content">
          <div class="spinner"></div>
          <div style="margin-top:16px;color:var(--muted);font-size:14px">Generating questions...</div>
        </div>
      </div>

      <div class="card">
        <div class="meta" id="progress">Question 0 of 0</div>
        <div id="cards" class="quiz-grid">
          <!-- Single-card exam UI will be rendered client-side. If any initial cards were passed, they will be shown by JS. -->
        </div>
      </div>

      <div class="fixed-controls">
        <div class="control-row" style="display:flex;gap:12px;align-items:center">
          <div class="left-controls" style="flex:1;display:flex;gap:8px;align-items:center">
            <button id="prev" class="btn ghost prev-button" style="width:100%">Previous</button>
          </div>
          <div class="right-controls" style="flex:4">
            <button id="next" class="btn next-button" style="width:100%">Next</button>
          </div>
        </div>
      </div>

      <!-- three-dots menu replaces previous floating controls -->

    </div>

    <script>
      (function(){
        'use strict';
        
        const deckId = document.getElementById('deck-id').textContent.trim();
        const cardsContainer = document.getElementById('cards');
        
        // Exam state
        const cards = [];
        let currentIndex = 0;

        const prevBtn = document.getElementById('prev');
        const nextBtn = document.getElementById('next');
        const progress = document.getElementById('progress');
        const loadingIndicator = document.getElementById('loading-indicator');
        
        let eventSource = null;
        let hasShownFirstCard = false;

        // Sound effects: prefer short hosted MP3s, fallback to WebAudio tones
        const CORRECT_SOUND_URL = 'https://cdn.pixabay.com/audio/2025/07/07/audio_a6bac2e47a.mp3';
        const INCORRECT_SOUND_URL = 'https://cdn.pixabay.com/audio/2022/11/20/audio_4d2cc8231f.mp3';

        const correctAudio = new Audio(CORRECT_SOUND_URL);
        correctAudio.preload = 'auto';
        correctAudio.crossOrigin = 'anonymous';

        const incorrectAudio = new Audio(INCORRECT_SOUND_URL);
        incorrectAudio.preload = 'auto';
        incorrectAudio.crossOrigin = 'anonymous';

        const audioCtx = (function() {
          try { return new (window.AudioContext || window.webkitAudioContext)(); } catch(e) { return null; }
        })();

        function playTone(freq, type = 'sine', duration = 0.12, gain = 0.12) {
          if (!audioCtx) return;
          const o = audioCtx.createOscillator();
          const g = audioCtx.createGain();
          o.type = type;
          o.frequency.value = freq;
          g.gain.value = gain;
          o.connect(g); g.connect(audioCtx.destination);
          o.start();
          o.stop(audioCtx.currentTime + duration);
        }

        function playCorrectSound() {
          // Try audio file first
          try {
            const a = correctAudio.cloneNode();
            const p = a.play();
            if (p && p.catch) p.catch(() => { /* autoplay blocked — fallback */ playTone(900,'sine',0.08,0.08); setTimeout(()=>playTone(1200,'sine',0.12,0.12),90); });
            return;
          } catch (e) {
            // ignore and fallback
          }
          // Fallback to WebAudio tones
          if (audioCtx) {
            playTone(900, 'sine', 0.08, 0.08);
            setTimeout(() => playTone(1200, 'sine', 0.12, 0.12), 90);
          }
        }

        function playIncorrectSound() {
          try {
            const a = incorrectAudio.cloneNode();
            const p = a.play();
            if (p && p.catch) p.catch(() => { playTone(160,'square',0.12,0.18); setTimeout(()=>playTone(120,'sawtooth',0.12,0.12),120); });
            return;
          } catch (e) {}
          if (audioCtx) {
            playTone(160, 'square', 0.12, 0.18);
            setTimeout(() => playTone(120, 'sawtooth', 0.12, 0.12), 120);
          }
        }

        function renderCardAt(index) {
          const slot = document.getElementById('card-slot');
          if (!slot) return;
          
          // Animate card exit
          const currentCard = slot.querySelector('.card-quiz');
          if (currentCard) {
            currentCard.style.opacity = '0';
            currentCard.style.transform = 'translateX(-20px) scale(0.95)';
            currentCard.style.transition = 'opacity 0.3s ease, transform 0.3s ease';
          }
          
          setTimeout(() => {
          slot.innerHTML = '';
            
            if (cards.length === 0) {
            slot.innerHTML = '<div class="card-quiz"><div class="q">No cards yet — waiting for generation</div></div>';
            progress.textContent = 'Question 0 of 0';
              prevBtn.disabled = true;
              nextBtn.disabled = true;
              const emptyCard = slot.querySelector('.card-quiz');
              if (emptyCard) {
                emptyCard.style.opacity = '0';
                emptyCard.style.transform = 'scale(0.9)';
                setTimeout(() => {
                  emptyCard.style.transition = 'opacity 0.3s ease, transform 0.3s ease';
                  emptyCard.style.opacity = '1';
                  emptyCard.style.transform = 'scale(1)';
                }, 10);
              }
            return;
          }
            
            const card = cards[index];
            if (!card) return;
            
            // Animate progress update
            progress.style.transform = 'scale(1.1)';
            progress.style.transition = 'transform 0.2s ease';
            progress.textContent = `Question ${index + 1} of ${cards.length}`;
            setTimeout(() => {
              progress.style.transform = 'scale(1)';
            }, 200);

            const wrapper = document.createElement('div');
            wrapper.className = 'card-quiz';
            wrapper.setAttribute('data-card-id', card.card_id);
          
          if (card.card_type) {
            const badge = document.createElement('div');
            badge.className = 'badge';
            badge.textContent = card.card_type;
            wrapper.appendChild(badge);
          }
          
          if (card.case_details) {
            const caseDiv = document.createElement('div');
            caseDiv.className = 'case';
            caseDiv.innerHTML = `<em>Case:</em> ${card.case_details}`;
            wrapper.appendChild(caseDiv);
          }
          
          const questionDiv = document.createElement('div');
          questionDiv.className = 'q';
          questionDiv.textContent = card.question;
          wrapper.appendChild(questionDiv);

          if (card.options && card.options.length) {
            const optionsContainer = document.createElement('div');
            optionsContainer.className = 'options';
            
            card.options.forEach((option, optionIndex) => {
              const label = document.createElement('label');
              label.className = 'option';
              
              const input = document.createElement('input');
              input.type = 'radio';
              input.name = 'answer';
              input.value = option;
              input.id = `opt${optionIndex}`;
              label.appendChild(input);

              const inner = document.createElement('div');
              inner.className = 'option-inner';
              
              const textDiv = document.createElement('div');
              textDiv.className = 'option-text';
              textDiv.textContent = option;
              inner.appendChild(textDiv);
                
              // Add icon containers for checkmark/X
                const checkIcon = document.createElement('div');
                checkIcon.className = 'option-icon check-icon';
                checkIcon.innerHTML = '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"><polyline points="20 6 9 17 4 12"></polyline></svg>';
                
                const xIcon = document.createElement('div');
                xIcon.className = 'option-icon x-icon';
                xIcon.innerHTML = '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>';
                
                inner.appendChild(checkIcon);
                inner.appendChild(xIcon);
              label.appendChild(inner);

                // Add click animation
              label.addEventListener('click', function() {
                if (label.dataset.locked) return;
                  inner.classList.add('animating');
                  setTimeout(() => {
                    inner.classList.remove('animating');
                  }, 400);
                });

              // Immediate validation when user selects an option
              input.addEventListener('change', function() {
                if (label.dataset.locked) return;
                label.dataset.locked = '1';

                const answerDiv = wrapper.querySelector('.answer');
                const cardTypeLower = String(card.card_type || '').toLowerCase();
                
                  // Understanding/explanation type — show blurred content, allow reveal
                if (cardTypeLower.includes('understand') && answerDiv) {
                  answerDiv.style.display = 'block';
                  answerDiv.classList.add('blurred');
                  
                  const revealHandler = function() {
                    answerDiv.classList.remove('blurred');
                    answerDiv.classList.add('revealed');
                    answerDiv.removeEventListener('click', revealHandler);
                  };
                  answerDiv.addEventListener('click', revealHandler);
                  
                  // Lock inputs
                  wrapper.querySelectorAll('input[name=answer]').forEach(inp => inp.disabled = true);
                    return;
                  }

                  // MCQ / standard validation
                const selectedValue = input.value;
                const isCorrect = selectedValue === (card.answer || '');

                // Clear any previous highlights and icons
                wrapper.querySelectorAll('.option-inner').forEach(optionInner => {
                  optionInner.classList.remove('correct', 'incorrect');
                  optionInner.querySelectorAll('.option-icon').forEach(icon => {
                      icon.style.opacity = '0';
                      icon.style.transform = 'translateY(-50%) scale(0)';
                      icon.style.display = 'flex';
                    });
                  });

                  // Add slight delay for better animation effect
                  setTimeout(() => {
                  const chosenInner = input.closest('.option').querySelector('.option-inner');
                  if (chosenInner) {
                    if (isCorrect) {
                        chosenInner.classList.add('correct');
                      try { playCorrectSound(); } catch(e){}
                      const check = chosenInner.querySelector('.check-icon');
                      const x = chosenInner.querySelector('.x-icon');
                      if (check) {
                        check.style.opacity = '1';
                        check.style.transform = 'translateY(-50%) scale(1)';
                        check.style.display = 'flex';
                        }
                      if (x) {
                        x.style.display = 'none';
                      }
                    } else {
                        chosenInner.classList.add('incorrect');
                      try { playIncorrectSound(); } catch(e){}
                      const check = chosenInner.querySelector('.check-icon');
                      const x = chosenInner.querySelector('.x-icon');
                      if (x) {
                        x.style.opacity = '1';
                        x.style.transform = 'translateY(-50%) scale(1)';
                        x.style.display = 'flex';
                        }
                      if (check) {
                        check.style.display = 'none';
                        }
                      
                      // Highlight correct one with delay
                      setTimeout(() => {
                        const correctInput = Array.from(wrapper.querySelectorAll('input[name=answer]'))
                          .find(inp => inp.value === (card.answer || ''));
                        if (correctInput) {
                          const correctInner = correctInput.closest('.option').querySelector('.option-inner');
                          if (correctInner) {
                            correctInner.classList.add('correct');
                            const check = correctInner.querySelector('.check-icon');
                            const x = correctInner.querySelector('.x-icon');
                            if (check) {
                              check.style.opacity = '1';
                              check.style.transform = 'translateY(-50%) scale(1)';
                              check.style.display = 'flex';
                            }
                            if (x) {
                              x.style.display = 'none';
                            }
                          }
                        }
                      }, 200);
                    }
                  }

                  // Show answer text if an answer block exists
                  if (answerDiv) {
                    answerDiv.style.display = 'block';
                    answerDiv.textContent = `${isCorrect ? 'Correct — ' : 'Incorrect — '}Answer: ${card.answer || ''}`;
                  }

                  // Lock inputs
                  wrapper.querySelectorAll('input[name=answer]').forEach(inp => inp.disabled = true);
                }, 50);
                });

              optionsContainer.appendChild(label);
            });
            wrapper.appendChild(optionsContainer);
          }

          // For understanding/explanation cards render a blurred explanation block that can be revealed
          const cardTypeLower = String(card.card_type || '').toLowerCase();
          if (cardTypeLower.includes('understand')) {
            const answerDiv = document.createElement('div');
            answerDiv.className = 'answer';
            answerDiv.textContent = card.explanation || card.answer || '';
            answerDiv.style.display = 'block';
            answerDiv.classList.add('blurred');
            
            const revealHandler = function() {
              answerDiv.classList.remove('blurred');
              answerDiv.classList.add('revealed');
              answerDiv.removeEventListener('click', revealHandler);
            };
            answerDiv.addEventListener('click', revealHandler);
            wrapper.appendChild(answerDiv);
          }
          
            cardsContainer.innerHTML = '';
            const slotWrap = document.createElement('div');
            slotWrap.id = 'card-slot';
            slotWrap.appendChild(wrapper);
          cardsContainer.appendChild(slotWrap);

            // Animate card entrance
            wrapper.style.opacity = '0';
            wrapper.style.transform = 'translateX(20px) scale(0.95)';
            setTimeout(() => {
              wrapper.style.transition = 'opacity 0.4s cubic-bezier(0.34, 1.56, 0.64, 1), transform 0.4s cubic-bezier(0.34, 1.56, 0.64, 1)';
              wrapper.style.opacity = '1';
              wrapper.style.transform = 'translateX(0) scale(1)';
            }, 10);

            // Update navigation buttons with animation
            const wasPrevDisabled = prevBtn.disabled;
            const wasNextDisabled = nextBtn.disabled;
            prevBtn.disabled = (index === 0);
            nextBtn.disabled = (index >= cards.length - 1);
            
            // Animate button state changes
            if (wasPrevDisabled !== prevBtn.disabled || wasNextDisabled !== nextBtn.disabled) {
              [prevBtn, nextBtn].forEach(btn => {
                btn.style.transform = 'scale(0.95)';
                setTimeout(() => {
                  btn.style.transition = 'transform 0.2s ease';
                  btn.style.transform = 'scale(1)';
                }, 10);
              });
            }
          }, 300);
        }

        prevBtn.addEventListener('click', function() {
          if (currentIndex > 0) {
            // Button click animation
            this.style.transform = 'scale(0.9)';
            setTimeout(() => {
              this.style.transform = 'scale(1)';
            }, 100);
            currentIndex--;
            renderCardAt(currentIndex);
          }
        });
        
        nextBtn.addEventListener('click', function() {
          if (currentIndex < cards.length - 1) {
            // Button click animation
            this.style.transform = 'scale(0.9)';
            setTimeout(() => {
              this.style.transform = 'scale(1)';
            }, 100);
            currentIndex++;
            renderCardAt(currentIndex);
          }
        });
        
        // Initialize button transitions
        prevBtn.style.transition = 'transform 0.2s ease';
        nextBtn.style.transition = 'transform 0.2s ease';

        // Selection is handled immediately on input change (see input listeners created when rendering options).

        // Initial empty slot
        const slotInit = document.createElement('div');
        slotInit.id = 'card-slot';
        cardsContainer.appendChild(slotInit);

        function hideLoadingIndicator() {
          if (loadingIndicator && !hasShownFirstCard) {
            loadingIndicator.style.opacity = '0';
            loadingIndicator.style.transition = 'opacity 0.4s ease';
            setTimeout(() => {
            loadingIndicator.style.display = 'none';
            hasShownFirstCard = true;
            }, 400);
          }
        }

        // Connect EventSource
        function connectEventSource() {
          eventSource = new EventSource(`/stream_cards/${encodeURIComponent(deckId)}`);
          
          eventSource.onmessage = function(event) {
            try {
              const payload = JSON.parse(event.data);
              if (!payload || !payload.cards) return;
              
              let hasNewCards = false;
            payload.cards.forEach(card => {
                if (!card.card_id) return;
                if (!cards.find(c => c.card_id === card.card_id)) {
                cards.push(card);
                  hasNewCards = true;
              }
            });
              
              // Render current card when ready with animation
              if (hasNewCards) {
                // Add a slight delay for smooth animation
                setTimeout(() => {
                  renderCardAt(currentIndex);
                  // Hide loading indicator when first card appears
                  if (cards.length > 0) {
              hideLoadingIndicator();
            }
                }, 50);
              }
            } catch (err) {
              console.error('Invalid message:', err, event.data);
            }
        };

          eventSource.addEventListener('done', function() {
            if (eventSource) {
              eventSource.close();
              eventSource = null;
            }
          });

          eventSource.onerror = function(err) {
            console.error('EventSource failed:', err);
            // Attempt to reconnect after a delay
            if (eventSource) {
              eventSource.close();
              eventSource = null;
              setTimeout(connectEventSource, 5000);
            }
          };
        }
        
        connectEventSource();
        
        // Cleanup on page unload
        window.addEventListener('beforeunload', function() {
          if (eventSource) {
            eventSource.close();
            eventSource = null;
          }
        });

        // Initialize Telegram WebApp
        initTelegramWebApp();

        // Notify admin when mini app is opened
        notifyAdmin('quiz');

        // New three-dots menu behavior: toggle menu, copy id, share to Telegram
        const menuBtn = document.getElementById('menu-btn');
        const menuPopup = document.getElementById('menu-popup');
        const quizIdDisplay = document.getElementById('quiz-id-display');
        const copyIdAction = document.getElementById('copy-id-action');
        const shareTelegramAction = document.getElementById('share-telegram-action');
        let isSending = false;

        function showMenu() {
          // Append popup to body to avoid stacking-context issues
          try {
            const rect = menuBtn.getBoundingClientRect();
            // Move to body if not already
            if (menuPopup.parentElement !== document.body) {
              document.body.appendChild(menuPopup);
            }
            // Prepare popup for measurement
            menuPopup.style.display = 'block';
            menuPopup.style.position = 'absolute';
            menuPopup.style.visibility = 'hidden';
            menuPopup.style.zIndex = '3000';

            // Allow browser to compute sizes
            const popupWidth = menuPopup.offsetWidth;
            const top = rect.bottom + window.scrollY + 8;

            // Responsive behavior: if viewport narrow, make popup full-width with margins
            const viewportWidth = document.documentElement.clientWidth;
            let left;
            if (viewportWidth <= 420) {
              const margin = 16;
              const targetWidth = Math.max(200, viewportWidth - margin * 2);
              menuPopup.style.width = targetWidth + 'px';
              left = window.scrollX + margin;
            } else {
              // Position aligned under the button, keep popup within viewport
              let computedWidth = popupWidth;
              left = rect.right + window.scrollX - computedWidth;
              left = Math.max(8 + window.scrollX, Math.min(left, window.scrollX + viewportWidth - computedWidth - 8));
            }

            menuPopup.style.top = top + 'px';
            menuPopup.style.left = left + 'px';
            menuPopup.style.visibility = 'visible';
            menuBtn.setAttribute('aria-expanded', 'true');
          } catch (err) {
            // fallback
            menuPopup.style.display = 'block';
            menuBtn.setAttribute('aria-expanded', 'true');
          }
        }

        function hideMenu() {
          menuPopup.style.display = 'none';
          menuBtn.setAttribute('aria-expanded', 'false');
        }

        menuBtn.addEventListener('click', function(e) {
          e.stopPropagation();
          if (menuPopup.style.display === 'block') hideMenu(); else showMenu();
        });

        // Close on outside click
        document.addEventListener('click', function(e) {
          if (!menuPopup.contains(e.target) && e.target !== menuBtn && !menuBtn.contains(e.target)) {
            hideMenu();
          }
        });

        // Copy ID
        copyIdAction.addEventListener('click', function(e) {
          e.stopPropagation();
          const quizId = quizIdDisplay.textContent.trim();
          const btn = copyIdAction;
          if (navigator.clipboard && navigator.clipboard.writeText) {
            navigator.clipboard.writeText(quizId).then(function() {
              const original = btn.textContent;
              btn.textContent = 'Copied!';
              btn.style.background = 'var(--accent)';
              btn.style.color = 'white';
              setTimeout(function() {
                btn.textContent = original;
                btn.style.background = '';
                btn.style.color = '';
              }, 1600);
            }).catch(function() {
              alert(`Failed to copy. Quiz ID: ${quizId}`);
            });
          } else {
            const ta = document.createElement('textarea');
            ta.value = quizId;
            ta.style.position = 'fixed'; ta.style.opacity = '0'; ta.style.left = '-9999px';
            document.body.appendChild(ta); ta.select();
            try { document.execCommand('copy'); btn.textContent = 'Copied!'; setTimeout(()=> btn.textContent = 'Copy ID', 1600); } catch (e) { alert(`Failed to copy. Quiz ID: ${quizId}`); }
            document.body.removeChild(ta);
          }
          hideMenu();
        });

        // Share to Telegram
        shareTelegramAction.addEventListener('click', async function(e) {
          e.stopPropagation();
          if (isSending || cards.length === 0) return;

          const userInfo = getTelegramUserInfo();
          if (!userInfo.id) {
            alert('Unable to get your Telegram user ID. Please open this from Telegram.');
            hideMenu();
            return;
          }

          const confirmSend = confirm(`Send ${cards.length} question${cards.length > 1 ? 's' : ''} to your Telegram chat?`);
          if (!confirmSend) {
            hideMenu();
            return;
          }

          isSending = true;
          const btn = shareTelegramAction;
          btn.disabled = true; btn.style.opacity = '0.7'; btn.style.animation = 'pulse 1s ease-in-out infinite';

          let result = null;
          try {
            const resp = await fetch('/api/send-to-telegram', {
              method: 'POST', headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ cards: cards, user_id: userInfo.id })
            });
            result = await resp.json();
            if (result && result.success) {
              alert(`✅ Sent ${result.sent} question${result.sent > 1 ? 's' : ''} to your Telegram chat${result.skipped ? ` (skipped ${result.skipped})` : ''}`);
            } else {
              alert(`❌ Failed to send: ${result && result.error ? result.error : 'Unknown error'}`);
            }
          } catch (err) {
            console.error('Error sending to Telegram:', err);
            alert('❌ Error sending questions to Telegram. Please try again.');
          } finally {
            isSending = false; btn.disabled = false; btn.style.opacity = '1'; btn.style.animation = '';
            // small success highlight
            if (result && result.success) {
              btn.style.background = 'linear-gradient(135deg, var(--success), #16a34a)';
              setTimeout(() => btn.style.background = '', 1800);
            }
            hideMenu();
          }
        });

        // Export buttons
        Array.from(menuPopup.querySelectorAll('button[data-export]')).forEach(function(btn) {
          btn.addEventListener('click', function(e) {
            e.stopPropagation();
            const fmt = btn.getAttribute('data-export');
            // Open export in new tab to trigger download
            const url = `/export/${encodeURIComponent(deckId)}?format=${encodeURIComponent(fmt)}`;
            window.open(url, '_blank');
            hideMenu();
          });
        });
        
      })();
    </script>
  </body>
</html>
